1.垃圾回收机制(与main方法一样)是一个单独的线程

 	public void finalize()()  当垃圾回收时会自动调用该方法   (可在自定义对象中重写 实现特定的操作)
 
 	System.gc();   作用启动垃圾回收器  但是具体什么时候进行垃圾回收不确定
 	
2.进程与线程
	进程：正在进行的程序
	线程：运行程序的一条路径
3.如何创建一个线程？

	方式一：继承thread类
 
		 * 步骤：
		 * 1.定义一个类继承Thread类
		 * 2.覆盖thread类中的run方法
		 * 3.直接创建Thread类的子类对象
		 * 4.调用start方法  开启线程并调用线程的任务run方法执行
	 
		3.1调用run和调用start 有什么区别
			start 启动一个线程
			run  存放线程运行的代码块
			
		3.2课外知识点：
			1.可以调用Thread类的getName方法  获取到线程的名字 用于区分线程
			
			2.Thread的静态方法   currentThread() 获取到当前运行的线程
			
			3.主线程的名字  main
			
		注意：一个线程发生了异常 并不会影响其他线程！！！
	
	方式二：实现Runnable接口
		步骤：
		 *1.定义类实现Runnable接口
		 
		 * 2.覆盖接口中的run方法，将线程的任务代码封装到run方法中
		 
		 * 3.通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread构造函数的参数进行传递
		  			【为什么？  因为线程的任务都封装到Runnable 接口的子类对象的run方法中了。】
		  			
		 * 4.调用线程对象的start 方法开启线程
		 
		 3.1 实现Runnable接口的好处：
		 
		 	1.将线程的任务从线程的子类中分离出来，进行了单独的封装 ，按照面向对象的思想将任务封装成对象
		 	
		    2.避免了java单继承的局限性 
 
 	 所以创建线程的第二种方式较为常用
	